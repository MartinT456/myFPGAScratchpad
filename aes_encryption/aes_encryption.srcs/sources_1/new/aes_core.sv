`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Written by: Martin Tran
// 
// Create Date: 01/18/2025 
//
// Module Name: aes_core
// Project Name: aes_encryption
//
// Description: 
// This module implements the AES-128 encryption process, which takes a 128-bit
// plaintext and a 128-bit encryption key as inputs and produces a 128-bit
// ciphertext as output. The module follows the standard AES encryption steps,
// including AddRoundKey, SubBytes, ShiftRows, MixColumns, and key expansion. It
// performs 10 rounds of encryption as per the AES-128 specification, with a
// final round that omits the MixColumns step.
//
// Interface:
// Inputs:
// - input logic clk: Clock signal to synchronize operations.
// - input logic reset: Reset signal to initialize the module state.
// - input logic [127:0] plaintext: 128-bit plaintext input to be encrypted.
// - input logic [127:0] key: 128-bit encryption key for the AES process.
//
// Outputs:
// - output logic [127:0] ciphertext: 128-bit encrypted output produced by AES algorithm.
//
// Internal Signals:
// - logic [127:0] state: Represents the current state of the AES encryption process.
// - logic [127:0] round_keys [0:10]: Stores the 11 round keys generated by the
//   key_expansion module.
// - integer round: Tracks the current round of encryption (0 to 10).
//
// Submodules:
// key_expansion:
//    - Generates the 11 round keys required for the AES-128 encryption.
//
// sub_bytes:
//    - Applies the SubBytes transformation to the AES state using an S-Box lookup.

// shift_rows:
//    - Performs the ShiftRows transformation, which cyclically shifts rows in the AES state.
//
//  mix_columns:
//    - Applies the MixColumns transformation, which mixes each column in the AES state.
//
//
// Operation:
// - On reset, the module initializes its state, round counter, and ciphertext to zero.
// - Round 0:
//   - XORs the plaintext with the first round key (round_keys[0], being the same as initial input key).
// - Rounds 1 to 9:
//   - Sequentially applies the SubBytes, ShiftRows, MixColumns, and AddRoundKey transformations.
// - Round 10:
//   - Applies the SubBytes, ShiftRows, and AddRoundKey transformations (no MixColumns in the final round).
//   - Produces the final ciphertext as output.
// - After completing all 10 rounds, the round counter resets, and the module is
//   ready for the next encryption.
//
//////////////////////////////////////////////////////////////////////////////////


module aes_core(
    input logic clk,
    input logic reset,
    input logic [127:0] plaintext,        // plaintext input
    input logic [127:0] key,             // encyption key
    output logic [127:0] ciphertext        // ciphertext output
    );
    
    logic [127:0] state; // encryption state
    logic [127:0] round_keys [0:10]; // 11 keys for AES-128
    int round; // keeping track of current round
    
    logic [127:0] sub_bytes_out, shift_rows_out, mix_columns_out;
    
    // Generates round keys and stores them
    key_expansion inst_key_expansion(
        .reset(reset), 
        .clk(clk), 
        .key(key), 
        .round_keys(round_keys)
    );
    
    /*
       Module instances takes current state as input to sub_bytes, permutes/transforms
       the state for one round of exncryption and stores result in mix_columns_out.
      (Except for round 10, which does not use the MixColumns step)
    */   
       
    sub_bytes inst_sub_bytes(.state_in(state), .state_out(sub_bytes_out));
    shift_rows inst_shift_rows(.state_in(sub_bytes_out), .state_out(shift_rows_out));
    mix_columns inst_mix_columns(.state_in(shift_rows_out), .state_out(mix_columns_out));
    
    // AES encryption process
    always_ff @(posedge clk or posedge reset) begin
        if (reset) begin
            state <= 128'b0;
            round <= 0;
            ciphertext <= 128'b0;
        end else begin
            if (round == 0) begin
                state <= plaintext ^ round_keys[0]; // Initial AddRoundKey
                round <= 1;
            end else if (round < 10) begin
                state <= mix_columns_out ^ round_keys[round];
                round <= round + 1;
            end else if (round == 10) begin
                state <= shift_rows_out ^ round_keys[10]; // Final round (does not use MixColumns as per AES standard)      
                round <= round + 1; // Allow one more clock cycle for signals to propagate before loading state to ciphertext
            end else begin
                ciphertext <= state; // Final ciphertext output
                round <= 0;
            end
        end
    end
    
    
endmodule